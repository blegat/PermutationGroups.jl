#########################################################
# Orbit Types and definitions
#########################################################

@inline Base.eltype(::AbstractOrbit{T}) where T = T

# each of them implements _Orbit Protocol_

include("OrbitT/Orbit1.jl")
include("OrbitT/Orbit2.jl")
include("OrbitT/Orbit3.jl")
include("OrbitT/Orbit4.jl")
include("OrbitT/Orbit5.jl")

const Orbit = Orbit1 # but the naive Vector+Dict is still the fastest...

for OrbT in [Symbol("Orbit", i) for i in 1:5]
    @eval begin
@doc doc"""
    Orbit(gens::Vector{<:GrouElem}, pt[, ^])
> Compute the orbit of a point `pt` under the action of group generated by `gens`.
> `nothing` is stored in the orbit, but the consecutive points.
"""
        function $OrbT(gens::AbstractVector{<:GroupElem}, pt::T, op=^) where T
            orb = $OrbT(pt)
            for o in orb
                for g in gens
                    γ = op(o, g)
                    if γ ∉ orb
                        push!(orb,γ)
                    end
                end
            end
            return orb
        end

@doc doc"""
    Orbit(::Type{Transversal}, gens::Vector{<:GrouElem}, pt[, ^])
> Compute the orbit of a point `pt` under the action of group generated by `gens`.
> Along the points the right transversal is stored as explicit group elements.
"""
        function $OrbT(::Type{Transversal}, gens::Vector{<:GroupElem}, pt::T, op=^) where T
            orb = $OrbT(pt, one(parent(first(gens))))
            for o in orb
                for g in gens
                    γ = op(o, g)
                    if γ ∉ orb
                        push!(orb,(γ, orb[o]*g))
                    end
                end
            end
            return orb
        end
    end
end

conjugacy_classes(G::AbstractAlgebra.Group) = conjugacy_classes_orbit(G)

function conjugacy_classes_orbit(G::AbstractAlgebra.AbstractPermutationGroup)

    id = one(G)
    S = gens(G)
    ordG = order(G)

    cclasses = [Orbit([id], Dict(id=>nothing))]
    perm_types = Dict(permtype(id) => [1])
    elts_counted = 1

    for g in G
        g_type = permtype(g)
        if haskey(perm_types, g_type)
            for idx in perm_types[g_type]
                g in cclasses[idx] && @goto nextelement
            end
            orb = Orbit(S, g, ^)
            elts_counted += length(orb)
            push!(cclasses, orb)
            push!(perm_types[g_type], lastindex(cclasses))
        else
            orb = Orbit(S, g, ^)
            elts_counted += length(orb)
            push!(cclasses, orb)
            perm_types[g_type] = [lastindex(cclasses)]
        end

        elts_counted == ordG && break
        @label nextelement
    end
    @assert elts_counted == ordG
    return cclasses
end
